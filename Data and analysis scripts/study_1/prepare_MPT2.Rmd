---
title: "MPT_model"
author: "Tong"
date: "12/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(afex)
library(emmeans)
library(runjags)
library(TreeBUGS)
library(tidybayes)
library(bayesplot)
```

## Step 1, prepare datasets

```{r}

# df <- read.csv("study_1_df.csv")
# 
# indiff_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition, within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2),
#             M3 = sum(type_3)) 

# edge_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2), 
#             E3 = sum(type_3)) 
# 
# allow_indi <- cbind(indiff_allow_indi, edge_allow_indi %>% select(-ID))
# 

# 
# indiff_not_allow_indi <- df %>% filter(between_subject_condition == "ties_not_allowed", within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_not_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2)) %>% unique()
# 
# edge_not_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_not_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2)) %>% unique()

# not_allow_indi <- cbind(indiff_not_allow_indi, edge_not_allow_indi %>% select(-ID))
# 
# write.csv(allow_indi, "allow_indi.csv", row.names = FALSE)
# write.csv(not_allow_indi, "not_allow_indi.csv", row.names = FALSE)

```


## step 2, run MPT models

In the most simple scenario, the following steps are required:

2.1. Define path to existing MPT model file in .eqn format (cf. multiTree; Moshagen, 2010)
2.2. Define path to data set with individual frequencies (.csv file: comma separated, rows=persons, columns=labeled categories)
2.3. Call one of the fitting functions `betaMPT` or `traitMPT` (examples below)
2.4. Check convergence of MCMC chains
2.5. Summarize and plot results


#### step 2.1, prepare MPT model equations
 
```{r}
readEQN(file = "cat_linear_rank.eqn",       # relative or absolute path 
        #restrictions = list(),  # equality constraints
        paramOrder = TRUE) 
```

#### step 2.2, prepare dataset

*Note that category labels (e.g., hit, miss,...) must start with a letter (different to multiTree or HMMTree) and match the column names of in data.

Testing the homogeneity of participants

```{r}
not_allow_indi <- read.csv("not_allow_indi.csv")[,3:8]
head(not_allow_indi)

# Testing the homogeneity of participants
testHetChi(freq = not_allow_indi,
            tree = c("M","M","M","E","E","E")) 
```

#### step 2.3, fit the model
```{r}
fit_linear_betaMPT <- betaMPT(
      eqnfile="cat_linear_rank.eqn",         # .eqn file
      data="not_allow_indi.csv", # parameter restrictions (or path to file,
      transformedParameters =list("deltal=lm-le", "deltat1 = t1m-t1e"), 
      parEstFile = "results_fit_linear_betaMPT.txt",
      ### optional MCMC input:            
     n.iter = 100000,             # number of iterations
     n.burnin = 50000,            # number of burnin samples that are removed
     n.thin = 100,                 # thinning rate of removing samples
     n.chains = 4                # number of MCMC chains (run in parallel)
)
```

#### step 2.4, Check convergence and model fit

```{r}
# Default: Traceplot and density

plot(fit_linear_betaMPT,    # fitted model
     parameter ="mean"      # which parameter to plot
)
# further arguments are passed to ?plot.mcmc.list
# Auto-correlation plots:
plot(fit_linear_betaMPT,  parameter = "mean", type = "acf")
# Gelman-Rubin plots:
plot(fit_linear_betaMPT,  parameter = "mean", type = "gelman")


ppps = PPP(fit_linear_betaMPT)
ppps  # ideally PPP should be around .50
```


#### step 2.5, plot results

To obtain the summary after fitting the model, simply use:
```{r, eval=FALSE}
summary(fit_linear_betaMPT)
```

The following functions allow to plot parameter estimates, distributions, goodness of fit, and raw frequencies:

```{r, eval=FALSE}

# plotFit(fit_linear_betaMPT)               # observed vs. predicted mean frequencies
# plotFit(fit_linear_betaMPT, stat = "cov") # observed vs. predicted covariance
# plotFreq(fit_linear_betaMPT) # individual and mean raw frequencies per tree

```


## group-level parameter estimates
```{r}
# # save complete summary of individual estimates to file:
# getParam(fit_linear_betaMPT, parameter = "theta", 
#          stat = "summary", file = "linear_parameter.csv")
# 
# read.csv("linear_parameter.csv")
# 
# plotParam(fit_linear_betaMPT,     # estimated parameters
#           includeIndividual=TRUE  # whether to plot individual estimates
# )
# 
# plotDistribution(fit_linear_betaMPT)      # estimated hierarchical parameter distribution 
# # compare the distributions of individual posterior-mean estimates (gray histograms) against the group-level
# 


```




```{r}
mysample_linear_betaMPT <- getSamples(fit_linear_betaMPT, "mean")
tt_linear_betaMPT <- tidy_draws(mysample_linear_betaMPT)

  
p1 <- tt_linear_betaMPT %>% 
  pivot_longer(`mean[1]_le`: `mean[2]_lm`,
               names_to = "name_l",
               values_to = "value_l")  %>% 
  select(name_l, value_l, .chain, .iteration, .draw) %>% 
  mutate(name_l = ifelse(str_detect(name_l, "le"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_l, y = name_l)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter l") + ylab("event type")

p1

ggsave("linear_l_beta.png")


p2 <- tt_linear_betaMPT %>% 
  pivot_longer(`mean[3]_t1e`: `mean[4]_t1m`,
               names_to = "name_t1",
               values_to = "value_t1")  %>% 
  select(name_t1, value_t1, .chain, .iteration, .draw) %>% 
  mutate(name_t1 = ifelse(str_detect(name_t1, "t1e"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_t1, y = name_t1)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter t1") + ylab("event type")
p2

ggsave("linear_t1_beta.png")


```


```{r}
fit_linear_traitMPT <- traitMPT(eqnfile="cat_linear_rank.eqn",
                         data="not_allow_indi.csv", 
                         modelfilename = "linear_traitMPT.jags", 
                         transformedParameters =list("deltal=lm-le","deltat1 = t1m-t1e"), 
                         parEstFile = "results_fit_linear_traitMPT.txt",
                         n.chain = 4, n.iter = 100000,
                         n.burnin = 50000, n.thin = 100)

summary(fit_linear_traitMPT)



```

```{r}
plot(fit_linear_traitMPT,    # fitted model
     parameter ="mean"      # which parameter to plot
)
# further arguments are passed to ?plot.mcmc.list
# Auto-correlation plots:
plot(fit_linear_traitMPT,  parameter = "mean", type = "acf")
# Gelman-Rubin plots:
plot(fit_linear_traitMPT,  parameter = "mean", type = "gelman")


ppps = PPP(fit_linear_traitMPT)
ppps  # ideally PPP should be around .50
```



```{r}

mysample_linear_traitMPT <- getSamples(fit_linear_traitMPT, "mean")
tt_linear_traitMPT <- tidy_draws(mysample_linear_traitMPT)


p1 <- tt_linear_traitMPT %>% 
  pivot_longer(`mean[1]_le`: `mean[2]_lm`,
               names_to = "name_l",
               values_to = "value_l")  %>% 
  select(name_l, value_l, .chain, .iteration, .draw) %>% 
  mutate(name_l = ifelse(str_detect(name_l, "le"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_l, y = name_l)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter l") + ylab("event type")

p1

ggsave("linear_l_trait.png")


p2 <- tt_linear_traitMPT %>% 
  pivot_longer(`mean[3]_t1e`: `mean[4]_t1m`,
               names_to = "name_t1",
               values_to = "value_t1")  %>% 
  select(name_t1, value_t1, .chain, .iteration, .draw) %>% 
  mutate(name_t1 = ifelse(str_detect(name_t1, "t1e"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_t1, y = name_t1)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter t1") + ylab("event type")
p2

ggsave("linear_t1_trait.png")
```


