---
title: "MPT_model"
author: "Tong"
date: "12/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(afex)
library(emmeans)
library(runjags)
library(TreeBUGS)
library(tidybayes)
```

## Step 1, prepare datasets

```{r}
# prepare datasets

# df <- read.csv("study_1_df.csv")
# 
# indiff_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition, within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2),
#             M3 = sum(type_3)) 

# edge_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2), 
#             E3 = sum(type_3)) 
# 
# allow_indi <- cbind(indiff_allow_indi, edge_allow_indi %>% select(-ID))
# 

# 
# indiff_not_allow_indi <- df %>% filter(between_subject_condition == "ties_not_allowed", within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_not_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2)) %>% unique()
# 
# edge_not_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_not_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2)) %>% unique()

# not_allow_indi <- cbind(indiff_not_allow_indi, edge_not_allow_indi %>% select(-ID))
# 
# write.csv(allow_indi, "allow_indi.csv", row.names = FALSE)
# write.csv(not_allow_indi, "not_allow_indi.csv", row.names = FALSE)

```


## step 2, run MPT models

In the most simple scenario, the following steps are required:

2.1. Define path to existing MPT model file in .eqn format (cf. multiTree; Moshagen, 2010)
2.2. Define path to data set with individual frequencies (.csv file: comma separated, rows=persons, columns=labeled categories)
2.3. Call one of the fitting functions `betaMPT` or `traitMPT` (examples below)
2.4. Check convergence of MCMC chains
2.5. Summarize and plot results

## Beta-MPT

#### step 2.1, prepare MPT model equations
 
```{r}
readEQN(file = "cat_linear_rank.eqn",       # relative or absolute path 
        #restrictions = list(),  # equality constraints
        paramOrder = TRUE) 
```

#### step 2.2, prepare dataset

*Note that category labels (e.g., hit, miss,...) must start with a letter (different to multiTree or HMMTree) and match the column names of in data.

Testing the homogeneity of participants

```{r}
not_allow_indi <- read.csv("not_allow_indi.csv")[,3:8]
head(not_allow_indi)

# Testing the homogeneity of participants
testHetChi(freq = not_allow_indi,
            tree = c("M","M","M","E","E","E")) 
```

#### step 2.3, fit the model
```{r}
fit_linear_betaMPT <- betaMPT(
      eqnfile="cat_linear_rank.eqn",         # .eqn file
      data="not_allow_indi.csv", # parameter restrictions (or path to file,
      transformedParameters =list("deltal=lm-le", "deltat1 = t1m-t1e"), 
      parEstFile = "results_fit_linear_betaMPT.txt",
      ### optional MCMC input:            
      n.iter = 50000,             # number of iterations
      n.burnin = 10000,            # number of burnin samples that are removed
      n.thin = 10,                 # thinning rate of removing samples
      n.chains = 4                # number of MCMC chains (run in parallel)
)
```

#### step 2.4, Check convergence and model fit

```{r}
# Default: Traceplot and density

plot(fit_linear_betaMPT,    # fitted model
     parameter ="mean"      # which parameter to plot
)
# further arguments are passed to ?plot.mcmc.list
# Auto-correlation plots:
plot(fit_linear_betaMPT,  parameter = "mean", type = "acf")
# Gelman-Rubin plots:
plot(fit_linear_betaMPT,  parameter = "mean", type = "gelman")


```


```{r}
ppps = PPP(fit_linear_betaMPT)
ppps  # ideally PPP should be around .50
```


#### step 2.5, plot results

To obtain the summary after fitting the model, simply use:
```{r, eval=FALSE}
summary(fit_linear_betaMPT)
```

The following functions allow to plot parameter estimates, distributions, goodness of fit, and raw frequencies:

```{r, eval=FALSE}

plotFit(fit_linear_betaMPT)               # observed vs. predicted mean frequencies
plotFit(fit_linear_betaMPT, stat = "cov") # observed vs. predicted covariance
plotFreq(fit_linear_betaMPT) # individual and mean raw frequencies per tree

```


## group-level parameter estimates
```{r}
# save complete summary of individual estimates to file:
getParam(fit_linear_betaMPT, parameter = "theta", 
         stat = "summary", file = "linear_parameter.csv")

read.csv("linear_parameter.csv")

plotParam(fit_linear_betaMPT,     # estimated parameters
          includeIndividual=TRUE  # whether to plot individual estimates
)

plotDistribution(fit_linear_betaMPT)      # estimated hierarchical parameter distribution 
# compare the distributions of individual posterior-mean estimates (gray histograms) against the group-level



```


```{r}

```



