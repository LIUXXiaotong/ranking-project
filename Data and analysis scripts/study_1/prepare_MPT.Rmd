---
title: "MPT_model"
author: "Tong"
date: "12/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(afex)
library(emmeans)
library(runjags)
library(TreeBUGS)
library(tidybayes)
```

## Step 1, prepare datasets

```{r}
# prepare datasets

# df <- read.csv("study_1_df.csv")
# 
# indiff_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition, within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2),
#             M3 = sum(type_3)) 

# edge_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2), 
#             E3 = sum(type_3)) 
# 
# allow_indi <- cbind(indiff_allow_indi, edge_allow_indi %>% select(-ID))
# 

# 
# indiff_not_allow_indi <- df %>% filter(between_subject_condition == "ties_not_allowed", within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_not_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2)) %>% unique()
# 
# edge_not_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_not_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2)) %>% unique()

# not_allow_indi <- cbind(indiff_not_allow_indi, edge_not_allow_indi %>% select(-ID))
# 
# write.csv(allow_indi, "allow_indi.csv", row.names = FALSE)
# write.csv(not_allow_indi, "not_allow_indi.csv", row.names = FALSE)

```


#### Prepare for Multitree
```{r}
allow_indi <- read.csv("allow_indi.csv") 

count_f <- allow_indi %>%
  summarise(e1 = sum(mid_logical),
            e2 = sum(mid_type1),
            e3 = sum(mid_type2),
            e4 = sum(mid_type3),
            f1 = sum(edge_logical),
            f2 = sum(edge_type1),
            f3 = sum(edge_type2),
            f4 = sum(edge_type3))

count_f


250+123+149+24
380+5+157+4


```

## step 2, run MPT models

In the most simple scenario, the following steps are required:

2.1. Define path to existing MPT model file in .eqn format (cf. multiTree; Moshagen, 2010)
2.2. Define path to data set with individual frequencies (.csv file: comma separated, rows=persons, columns=labeled categories)
2.3. Call one of the fitting functions `betaMPT` or `traitMPT` (examples below)
2.4. Check convergence of MCMC chains
2.5. Summarize and plot results

## Beta-MPT

#### step 2.1, prepare MPT model equations
 
```{r}
readEQN(file = "cat_rank.eqn",       # relative or absolute path 
        #restrictions = list(),  # equality constraints
        paramOrder = TRUE) 
```

#### step 2.2, prepare dataset

*Note that category labels (e.g., hit, miss,...) must start with a letter (different to multiTree or HMMTree) and match the column names of in data.

Testing the homogeneity of participants

```{r}
allow_indi <- read.csv("allow_indi.csv")[,3:10]
not_allow_indi <- read.csv("not_allow_indi.csv")
head(allow_indi)
head(not_allow_indi)

# Testing the homogeneity of participants
testHetChi(freq = allow_indi,
            tree = c("M","M","M","M", "E","E","E","E")) 
```

#### step 2.3, fit the model
```{r}
fit_betaMPT <- betaMPT(
      eqnfile="cat_rank.eqn",         # .eqn file
      data="allow_indi.csv", # parameter restrictions (or path to file)
      
      ### optional MCMC input:            
      n.iter = 50000,             # number of iterations
      n.burnin = 10000,            # number of burnin samples that are removed
      n.thin = 10,                 # thinning rate of removing samples
      n.chains = 4                # number of MCMC chains (run in parallel)
)
```

#### step 2.4, Check convergence and model fit

```{r}
# Default: Traceplot and density

plot(fit_betaMPT,    # fitted model
     parameter ="mean"      # which parameter to plot
)
# further arguments are passed to ?plot.mcmc.list
# Auto-correlation plots:
plot(fit_betaMPT,  parameter = "mean", type = "acf")
# Gelman-Rubin plots:
plot(fit_betaMPT,  parameter = "mean", type = "gelman")


```


```{r}
ppps = PPP(fit_betaMPT)
ppps  # ideally PPP should be around .50
```


#### step 2.5, plot results

To obtain the summary after fitting the model, simply use:
```{r, eval=FALSE}
summary(fit_betaMPT)
```

The following functions allow to plot parameter estimates, distributions, goodness of fit, and raw frequencies:

```{r, eval=FALSE}

plotFit(fit_betaMPT)               # observed vs. predicted mean frequencies
plotFit(fit_betaMPT, stat = "cov") # observed vs. predicted covariance
plotFreq(fit_betaMPT) # individual and mean raw frequencies per tree

```


## group-level parameter estimates
```{r}
# save complete summary of individual estimates to file:
getParam(fit_betaMPT, parameter = "theta", 
         stat = "summary", file = "parameter.csv")

read.csv("parameter.csv")

plotParam(fit_betaMPT,     # estimated parameters
          includeIndividual=TRUE  # whether to plot individual estimates
)

plotDistribution(fit_betaMPT)      # estimated hierarchical parameter distribution


#Extract draws of variables in a Bayesian model fit into a tidy data format
les = gather_draws(fit_betaMPT$runjags, ) 

t <- fit_betaMPT$runjags
```






## latent trait MPT
```{r}
fit_traitMPT <- traitMPT(eqnfile="cat_rank.eqn",
                         data="allow_indi.csv", 
                         modelfilename = "traitMPT.jags", 
                         transformedParameters =list("deltal=lm-le", "deltat3 =t3m-t3e", "deltat1 = t1m-t1e"), 
                         parEstFile = "results_fit_traitMPT.txt",
                         n.chain = 4, n.iter = 50000,
                         n.burnin = 10000, n.thin = 10)
```
```{r}
summary(fit_traitMPT)
summary(fit_betaMPT)
```

