####### Hierarchical latent-trait MPT with TreeBGUS #####

 data{
for(s in 1:S){
  zeros[s] <- 0
}
}

 model{

 for (n in 1: subjs){

### MPT model equations:
T_E[n,1] <- (1-theta[1,n])*(1-theta[5,n])*theta[3,n]
T_E[n,2] <- (1-theta[1,n])*(1-theta[5,n])*(1-theta[3,n])
T_E[n,3] <- (1-theta[1,n])*theta[5,n]
T_E[n,4] <- theta[1,n]

T_M[n,1] <- (1-theta[2,n])*(1-theta[6,n])*theta[4,n]
T_M[n,2] <- (1-theta[2,n])*(1-theta[6,n])*(1-theta[4,n])
T_M[n,3] <- (1-theta[2,n])*theta[6,n]
T_M[n,4] <- theta[2,n]


### Multinomial likelihood:
response.T_E[n,1:4] ~ dmulti(T_E[n,1:4],items.T_E[n])
response.T_M[n,1:4] ~ dmulti(T_M[n,1:4],items.T_M[n])
}


### Hierarchical structure: 
    for(i in 1:subjs) {
      for(s in 1:S){
        theta[s,i] <- phi(mu[s] + xi[s]*delta.part.raw[s,i])
      }
    }
    

    # hyperpriors
    for(i in 1:subjs) {
      delta.part.raw[1:S,i] ~ dmnorm(zeros,T.prec.part[1:S,1:S])
    }

    
    T.prec.part[1:S,1:S] ~ dwish(V, df)
    Sigma.raw[1:S,1:S] <- inverse(T.prec.part[,])
    for(s in 1:S){
      mean[s] <- phi(mu[s])
      for(q in 1:S){
        Sigma[s,q] <- Sigma.raw[q,s]*xi[s]*xi[q]
      }
    }

    for(s in 1:S){
      for(q in 1:S){
        # Off-diagonal elements of S (correlations not affected by xi)
        rho[s,q] <- Sigma[s,q]/sqrt(Sigma[s,s]*Sigma[q,q])
      }
      # Diagonal elements of S (rescale sigma)
      sigma[s] <- sqrt(Sigma[s,s])
    }


mu[1] ~ dnorm(0,1)
mu[2] ~ dnorm(0,1)
mu[3] ~ dnorm(0,1)
mu[4] ~ dnorm(0,1)
mu[5] ~ dnorm(0,1)
mu[6] ~ dnorm(0,1)
xi[1] ~ dunif(0,10)
xi[2] ~ dunif(0,10)
xi[3] ~ dunif(0,10)
xi[4] ~ dunif(0,10)
xi[5] ~ dunif(0,10)
xi[6] ~ dunif(0,10)

### Transformed Parameters (on group level) ###
 
 deltal <- mean[2]-mean[1] 
 deltat3 <- mean[6]-mean[5] 
 deltat1 <- mean[4]-mean[3] 
}
