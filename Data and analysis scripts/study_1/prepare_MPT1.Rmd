---
title: "MPT_model"
author: "Tong"
date: "12/7/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(afex)
library(emmeans)
library(runjags)
library(TreeBUGS)
library(tidybayes)
```

## Step 1, prepare datasets

```{r}
# prepare datasets

# df <- read.csv("study_1_df.csv")
# 
# indiff_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition, within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2),
#             M3 = sum(type_3)) 

# edge_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2, type_3) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1),
#          type_3 = ifelse(is.na(type_3) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2), 
#             E3 = sum(type_3)) 
# 
# allow_indi <- cbind(indiff_allow_indi, edge_allow_indi %>% select(-ID))
# 

# 
# indiff_not_allow_indi <- df %>% filter(between_subject_condition == "ties_not_allowed", within_subject_condition == "indiff") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(condition = "ties_not_allowed",
#             ML = sum(logical),
#             M1 = sum(type_1),
#             M2 = sum(type_2)) %>% unique()
# 
# edge_not_allow_indi <- df %>% 
#   filter(between_subject_condition == "ties_not_allowed", 
#          within_subject_condition == "extreme") %>%
#   pivot_wider(names_from = classify_all_ranks, values_from = f00) %>% 
#   group_by(ID) %>%
#   select(ID, between_subject_condition,  within_subject_condition, 
#          logical, type_1, type_2) %>%
#   mutate(logical = ifelse(is.na(logical) == TRUE, 0, 1),
#          type_1 = ifelse(is.na(type_1) == TRUE, 0, 1),
#          type_2 = ifelse(is.na(type_2) == TRUE, 0, 1)) %>% 
#   group_by(ID) %>%
#   summarise(EL = sum(logical),
#             E1 = sum(type_1),
#             E2 = sum(type_2)) %>% unique()

# not_allow_indi <- cbind(indiff_not_allow_indi, edge_not_allow_indi %>% select(-ID))
# 
# write.csv(allow_indi, "allow_indi.csv", row.names = FALSE)
# write.csv(not_allow_indi, "not_allow_indi.csv", row.names = FALSE)

```


## step 2, run MPT models

In the most simple scenario, the following steps are required:

2.1. Define path to existing MPT model file in .eqn format (cf. multiTree; Moshagen, 2010)
2.2. Define path to data set with individual frequencies (.csv file: comma separated, rows=persons, columns=labeled categories)
2.3. Call one of the fitting functions `betaMPT` or `traitMPT` (examples below)
2.4. Check convergence of MCMC chains
2.5. Summarize and plot results

## Beta-MPT

#### step 2.1, prepare MPT model equations
 
```{r}
readEQN(file = "cat_rank.eqn",       # relative or absolute path 
        #restrictions = list(),  # equality constraints
        paramOrder = TRUE) 
```

#### step 2.2, prepare dataset

*Note that category labels (e.g., hit, miss,...) must start with a letter (different to multiTree or HMMTree) and match the column names of in data.

Testing the homogeneity of participants

```{r}
allow_indi <- read.csv("allow_indi.csv")[,3:10]
not_allow_indi <- read.csv("not_allow_indi.csv")
head(allow_indi)
head(not_allow_indi)

# Testing the homogeneity of participants
testHetChi(freq = allow_indi,
            tree = c("M","M","M","M", "E","E","E","E")) 
```

#### step 2.3, fit the model
```{r}
fit_betaMPT <- betaMPT(
      eqnfile="cat_rank.eqn",         # .eqn file
      data="allow_indi.csv", # parameter restrictions (or path to file,
      transformedParameters =list("deltal=lm-le", "deltat3 =t3m-t3e", "deltat1 = t1m-t1e"), 
      parEstFile = "results_fit_betaMPT.txt",
      ### optional MCMC input:            
      n.iter = 100000,             # number of iterations
      n.burnin = 50000,            # number of burnin samples that are removed
      n.thin = 100,                 # thinning rate of removing samples
      n.chains = 4                # number of MCMC chains (run in parallel)
)
```

#### step 2.4, Check convergence and model fit

```{r}
# Default: Traceplot and density

plot(fit_betaMPT,    # fitted model
     parameter ="mean"      # which parameter to plot
)
# further arguments are passed to ?plot.mcmc.list
# Auto-correlation plots:
plot(fit_betaMPT,  parameter = "mean", type = "acf")
# Gelman-Rubin plots:
plot(fit_betaMPT,  parameter = "mean", type = "gelman")



ppps = PPP(fit_betaMPT)
ppps  # ideally PPP should be around .50
```


#### step 2.5, plot results

To obtain the summary after fitting the model, simply use:
```{r, eval=FALSE}
summary(fit_betaMPT)
```

The following functions allow to plot parameter estimates, distributions, goodness of fit, and raw frequencies:

```{r, eval=FALSE}

plotFit(fit_betaMPT)               # observed vs. predicted mean frequencies
#plotFit(fit_betaMPT, stat = "cov") # observed vs. predicted covariance
plotFreq(fit_betaMPT) # individual and mean raw frequencies per tree

```


```{r}
mysample_betaMPT <- getSamples(fit_betaMPT, "mean")
tt_betaMPT <- tidy_draws(mysample_betaMPT)

  
p1 <- tt_betaMPT %>% 
  pivot_longer(`mean[1]_le`: `mean[2]_lm`,
               names_to = "name_l",
               values_to = "value_l")  %>% 
  select(name_l, value_l, .chain, .iteration, .draw) %>% 
  mutate(name_l = ifelse(str_detect(name_l, "le"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_l, y = name_l)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter l") + ylab("event type")

p1

ggsave("non_linear_l_beta.png")


p2 <- tt_betaMPT %>% 
  pivot_longer(`mean[3]_t1e`: `mean[4]_t1m`,
               names_to = "name_t1",
               values_to = "value_t1")  %>% 
  select(name_t1, value_t1, .chain, .iteration, .draw) %>% 
  mutate(name_t1 = ifelse(str_detect(name_t1, "t1e"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_t1, y = name_t1)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter t1") + ylab("event type")
p2

ggsave("non_linear_t1_beta.png")

p3 <- tt_betaMPT %>% 
  pivot_longer(`mean[5]_t3e`: `mean[6]_t3m`,
               names_to = "name_t3",
               values_to = "value_t3")  %>% 
  select(name_t3, value_t3, .chain, .iteration, .draw) %>% 
  mutate(name_t3 = ifelse(str_detect(name_t3, "t3e"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_t3, y = name_t3)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter t3") + ylab("event type")
p3

ggsave("non_linear_t3_beta.png")

```






## latent trait MPT
```{r}
fit_traitMPT <- traitMPT(eqnfile="cat_rank.eqn",
                         data="allow_indi.csv", 
                         modelfilename = "traitMPT.jags", 
                         transformedParameters =list("deltal=lm-le", "deltat3 =t3m-t3e", "deltat1 = t1m-t1e"), 
                         parEstFile = "results_fit_traitMPT.txt",
                         n.iter = 100000,             # number of iterations
                         n.burnin = 50000,            # number of burnin samples that are removed
                         n.thin = 100,                 # thinning rate of removing samples
                         n.chains = 4 )


```

```{r}
plot(fit_traitMPT,    # fitted model
     parameter ="mean"      # which parameter to plot
)
# further arguments are passed to ?plot.mcmc.list
# Auto-correlation plots:
plot(fit_traitMPT,  parameter = "mean", type = "acf")
# Gelman-Rubin plots:
plot(fit_traitMPT,  parameter = "mean", type = "gelman")



ppps = PPP(fit_traitMPT)
ppps
```

```{r}
mysample_traitMPT <- getSamples(fit_traitMPT, "mean")
tt_traitMPT <- tidy_draws(mysample_traitMPT)

  
p1 <- tt_traitMPT %>% 
  pivot_longer(`mean[1]_le`: `mean[2]_lm`,
               names_to = "name_l",
               values_to = "value_l")  %>% 
  select(name_l, value_l, .chain, .iteration, .draw) %>% 
  mutate(name_l = ifelse(str_detect(name_l, "le"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_l, y = name_l)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter l") + ylab("event type")

p1

ggsave("non_linear_l_trait.png")


p2 <- tt_traitMPT %>% 
  pivot_longer(`mean[3]_t1e`: `mean[4]_t1m`,
               names_to = "name_t1",
               values_to = "value_t1")  %>% 
  select(name_t1, value_t1, .chain, .iteration, .draw) %>% 
  mutate(name_t1 = ifelse(str_detect(name_t1, "t1e"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_t1, y = name_t1)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter t1") + ylab("event type")
p2

ggsave("non_linear_t1_trait.png")

p3 <- tt_traitMPT %>% 
  pivot_longer(`mean[5]_t3e`: `mean[6]_t3m`,
               names_to = "name_t3",
               values_to = "value_t3")  %>% 
  select(name_t3, value_t3, .chain, .iteration, .draw) %>% 
  mutate(name_t3 = ifelse(str_detect(name_t3, "t3e"), "edge events", "middle events")) %>%
  ggplot(aes(x = value_t3, y = name_t3)) +
  stat_halfeye() + theme_set(theme_bw()) + xlab("group-level estimates of parameter t3") + ylab("event type")
p3

ggsave("non_linear_t3_trait.png")

```


